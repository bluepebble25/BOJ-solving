const fs = require('fs');
const N = Number(fs.readFileSync('./input.txt').toString().trim());
const MOD = 1000000000;

function solution() {
  const dp = Array.from({ length: N + 1 }, () => Array(10).fill(0));

  for (let i = 1; i <= 9; i++) {
    dp[1][i] = 1;
  }

  for (let i = 2; i <= N; i++) {
    for (let j = 0; j <= 9; j++) {
      switch (j) {
        case 0:
          dp[i][j] = dp[i - 1][j + 1] % MOD;
          break;
        case 9:
          dp[i][j] = dp[i - 1][j - 1] % MOD;
          break;
        default:
          dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % MOD;
          break;
      }
    }
  }

  const sum = dp[N].reduce((acc, curr) => acc + curr, 0);
  return sum % MOD;
}

console.log(solution());

/*
  N=1일 때는 0을 제외한 1~9가 가능

  N=2
  첫번째 자리에 1~9 가능, 두번째 자리는 0~9 중 앞 자리와 1 차이나는 수 가능
  각 수는 0과 9를 제외하면 앞뒤로 1차이나는 수를 총 2개 가지고 있다.

  1 - 0, 2
  2 - 1, 3
  ...
  8 - 7, 9
  9 - 8

  2 * 8 + 1 = 17가지

  N=3
  1 - (0, 2) - 1, (1, 3)
  2 - (1, 3) - (0, 2), (2, 4)
  3 - (2, 4) - (1, 3), (3, 5)
  4 - (3, 5) - (2, 4), (4, 6)
  ...
  9 - 8 - (7, 9)

  이 숫자들을 보면 앞 자리 숫자가 0 혹은 9로 끝나면 뒷자리 숫자는 1개밖에 오지 못한다는 것을 알 수 있다.
  따라서 앞자리가 0, 9인가 아닌가 두 가지로 경우를 나눠 생각해야 한다.

  그리고 우리가 필요한 건 모든 가능한 계단수를 구하는 게 아니라 N자리 계단수를 구하는 것이다.
  N자리 계단수라는 것은 N-1 경우의 계단수가 각각 1개 혹은 2개씩 다른 수와 손을 잡은 형태이다.
  N번째 자리가 1이라는 것은 N-1번째 자리가 0인 경우 + N-1번째 자리가 2인 경우와 같다.

  따라서 dp를 2차원 배열로 만들어 첫번째 인덱스는 자리수를, 두번째 인덱스는 끝나는 수를 표시하도록 저장한다.

  점화식은
  1) 끝자리(j)가 0인 경우
  dp[i][j] = dp[i-1][j+1] (현재 수의 끝자리가 0이라는 건 이전 수의 끝자리가 1이었다는 의미니까 j+1)
  2) 끝자리(j)가 9인 경우
  dp[i][j] = dp[i-1][j-1] (현재 수의 끝자리가 9라는 건 이전 수의 끝자리가 8이었다는 의미니까)
  3) 그 외
  dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
*/
